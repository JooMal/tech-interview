# JAVA
### JavaBeans
자바로 작성된 소프트웨어 컴포넌트를 지칭하는 단어로, 이 컴포넌트를 **빈**이라 부른다. 값에 접근하고 꺼내올 수 있는 set, get 메소드를 구성하며, 기본 생성자가 반드시 존재해야 한다.
기본 생성자는 mybatis 사용을 위해서 파라미터가 없는 디폴트 생성자도 꼭 생성해주자.

### Struct vs Class
Struct : 언어적으로는 public, 관습적으로는 자료형
Class : 언어적으로는 private, 관습적으로는 내부 자료보다는 메소드가 중시되는 객체의 의미

### 메모리 영역
Stack : 원시타입 데이터들의 실제 값, Heap 영역에 생성된 Object 타입의 데이터 참조값(레퍼런스)가 올라간다.
Heap : 주로 긴 생명주기를 가지는 데이터들이 저장된다. 모든 Object 타입은 힙 영역에 생성되며, 몇 개의 스레드가 존재하든 상관없이 단 하나의 힙 영역만 존재한다.

### Collection
컬렉션은 오브젝트 타입의 객체로서 저장이 된다. 기본 데이터형의 경우에는 래퍼Wrapper 클래스를 이용하여 boxing해주거나 autoboxing으로 저장할 수 있다.

### ArrayList
리스트 인터페이스의 구현 클래스로, 여기서는 객체의 인덱스로 관리된다. 자바의 Array는 초기화 시 그 크기가 고정되어야하고, 사용 중에 크기를 변경할 수 없다는 점에서 Arraylist는 Array와 차이가 있다.
단점은 저장소의 용량을 늘리는 과정에서 많은 시간이 소요된다는 점이다. 따라서 ArrayList에서 용량을 늘린다는 것은 새로운 배열 인스턴스 생성과 기존 데이터 복사가 필요한 번거로운 작업이 된다.

### 왜 자바를 사용하는가?
플랫폼에 상관없이 돌아가는 코드를 작성할 수 있기 때문이다. C의 경우에는 .exe 파일이 만들어지기 때문에, 다른 운영체제에서 실행하기 위해서는 해당 OS에서 다시 컴파일을 해주어야 한다.
그러나 자바의 경우에는 실행하면 .class 파일이 만들어진다. 이는 바이트코드라는 **중간기계어**로, 운영체제에 맞는 실행을 위해서는 **JVM**이 필요하다. 즉 가상머신에서 먼저 실행해주고, **이 가상머신이 운영체제에 맞는 실행파일로 바꾸어준다.**

### 가비지 콜렉터
- 안정성
더이상 사용하지 않는 메모리인 **가비지**를 수거해준다. c/c++의 경우에는 필요없는 메모리 사용 해제를 free()를 이용하여 개발자가 직접 해주어야했으나, 자바는 가비지 컬렉터가 **사용하지 않는 동적 메모리를 주기적으로 수거**합니다.

### 메소드 시그니처
메소드의 선언부에 명시되는 **매개변수 리스트**. 만약 두 메소드가 매개변수의 개수와 타입, 그 순서까지 모두 같다면 **두 메소드의 시그니처는 같다**고 할 수 있다.

### 메소드 오버로딩
**같은 이름의 메소드를 중복하여 정의하는 것**을 의미한다. 자바에서는 원래 한 클래스 내에 같은 이름의 메소드를 둘 이상 가질 수 없는데, 매개변수의 개수나 타입을 다르게 하면, 즉 **서로 다른 시그니처**를 갖는 여러 메소드를 같은 이름으로 정의할 수 있다.
이를 이용하여 메소드에 사용되는 이름을 절약할 수 있다. 또한, 메소드를 호출할 때 전달해야 할 매개변수의 타입이나 개수에 대해 크게 신경을 쓰지 않고 호출할 수 있게 된다. 메소드 오버로딩은 객체 지향 프로그래밍의 특징 중 하나인 **다형성polymorphism**을 구현하는 방법 중 하나이다.
가령 다른 타입을 매개변수로 println() 메소드를 사용할 수 있음을 예시로 들 수 있다.

### 메소드 오버라이딩
상속 관계에 있는 부모 클래스에서 이미 정의된 메소드를 자식 클래스에서 **같은 시그니처를 갖는 메소드로 다시 정의하는 것**을 의미한다.
- 메소드의 **동작만을 재정의**하는 것으로, 메소드의 선언부는 기존 메소드와 완전히 같아야 한다. 하지만 **반환 타입**은 부모 클래스의 반환 타입으로 타입 변환이 가능한 타입이라면 변경가능하다.
- 부모 클래스의 메소드보다 접근 제어자를 더 좁은 범위로 변경할 수 없다.
- 부모 클래스의 메소드보다 더 큰 범위의 예외를 선언할 수 없다.

### 제네릭(Generic)
JDK 1.5부터 도입되었다. 데이터의 타입을 일반화하는 것을 의미한다. 클래스나 메소드에서 사용할 내부 데이터 타입을 **컴파일 시에 미리 지정하는 방법**이다. 이렇게 컴파일 시에 미리 타입 검사를 수행하는 이유는 무엇일까?
	1. 클래스나 메소드 내부에서 사용되는 객체의 타입 안정성을 높일 수 있다.
	2. 반환값에 대한 타입 변환 및 타입 검사에 들어가는 노력을 줄일 수 있다.
```java
class MyArray<T> {
	T element;
	void setElement(T element) { this.element = element; }
	T getElement() { return element; }
```

위의 예제에서 사용된 임의의 참조형 타입인 T처럼, 타입을 명시하여 고정할 수 있다. 
```java
MyArray<Integer> myArr = new MyArray<>();
MyArray<Integer> myArr = new MyArray<Integer>(); //generic class
```
이렇게 사용하면, 내부적으로는 타입 검사 후에 형변환을 진행한다. 단, 원시 타입을 바로 사용하는게 아니라, Integer와 같은 래퍼 클래스를 사용해주어야 한다.
컴파일된 class 파일에는 어떠한 제네릭 파일도 포함되지 않게 된다. 컴파일 시 컴파일러에 의해 자동으로 검사되어 타입 변환된 후, 코드 내 모든 제네릭 타입이 제거되기 때문이다. 제네릭을 사용하지 않는 코드와의 호환성 유지를 위해서이다.

### Wrapper Class
원시 타입을 객체화한 것으로, 메소드를 사용할 수 있게 된다.
- Boxing : Primitive type -> Wrapper type
- Unboxing = Wrapper type -> Primitive type
autoboxing, autounboxing 역시 최근엔 존재한다. 원시 타입과 다르게 래퍼 클래스는 객체이므로 **null도 넣어서 쓸 수 있다.**
extends 키워드를 사용하면 타입 변수에 특정 타입만을 사용하도록 제한할 수 있다. 인터페이스를 구현할 경우에도, implements 키워드가 아닌 extends 키워드를 사용하여 타입을 받아야 한다. 클래스와 인터페이스를 동시에 상속받고 구현해야 한다면, 엠퍼센트(&)를 사용할 수 있다.
```java
class AnimalList<T extends LandAnimal & WarmBlood> { ... }
```

### 와일드카드
와일드카드란 이름에 제한을 두지 않음을 표현하는 데에 사용되는 기호로, 자바의 제네릭에서는 물음표(?) 기호를 사용하여 이러한 와일드카드를 사용할 수 있다.
```java
<? extends T> // T 타입과 T 타입을 상속받는 자손 클래스만을 사용할 수 있음
<? super T> // T 타입과 T 타입이 상속받은 조상 클래스 타입만을 사용할 수 있음
```

### 인터페이스
자바에서는 다중 상속을 지원하지 않지만, 다중 상속의 이점을 갖고 오기 위하여 인터페이스를 사용한다.
단, 클래스와 달리 인터페이스의 모든 필드는 public static final이어야 하며, 모든 메소드는 public abstract이어야 한다.

### 싱글톤
객체 지향 프로그램에서 인스턴스를 단 하나만 생성하는 디자인 패턴을 으미한다. static으로 유일한 인스턴스를 생성하여 사용하며, public으로 외부에서 이를 사용할 수 있도록 만들어준다.
생성자가 여러 차례 호출되더라도, 실제로 생성되는 객체는 하나이고, 최초 생송 이후에 호출된 생성자는 최초에 생성한 객체를 반환한다.

### 싱글톤의 장점
- 메모리 낭비를 방지할 수 있다.
- 스레드풀, 커넥션풀 등 공통된 객체를 여러개 사용해서 사용해야 하는 상황에서 유리하다.

### 해시코드
객체를 식별하는 하나의 정수값이다. 오브젝트의 hashCode() 메소드는 객체의 메모리 번지를 이용하여 해시 코드를 만들어 리턴해주고, 그렇기 때문에 객체마다 고유한 값을 갖는다.
객체값의 동등성 비교시엔 hashCode() 메소드를 실행하여 리턴된 해시코드 값이 같은지 확인한다. 해시 코드값이 같으면 equals()로 객체의 내용도 같은지 비교한다. hashCode()와 equals()를 모두 통과하면 동등한 객체로 판단할 수 있다.
